/*
 *   Copyright (c) 2013-2022. LA Referencia / Red CLARA and others
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   This file is part of LA Referencia software platform LRHarvester v4.x
 *   For any further information please contact Lautaro Matas <lmatas@gmail.com>
 */

package org.lareferencia.core.task;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.lareferencia.core.domain.Network;
import org.lareferencia.core.worker.BaseWorker;
import org.lareferencia.core.worker.NetworkRunningContext;
import org.lareferencia.core.worker.management.NetworkCleanWorker;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import java.util.List;
import org.lareferencia.core.repository.catalog.OAIRecordCatalogRepository;
import org.lareferencia.core.repository.parquet.ValidationStatParquetRepository;
import org.lareferencia.core.service.validation.IValidationStatisticsService;
import org.lareferencia.core.metadata.ISnapshotStore;
import org.lareferencia.core.repository.jpa.NetworkRepository;

@DisplayName("NetworkCleanWorker Tests")
@ExtendWith(MockitoExtension.class)
class NetworkCleanWorkerTest {

    @Mock
    private ISnapshotStore snapshotStore;
    @Mock
    private IValidationStatisticsService validationStatisticsService;
    @Mock
    private OAIRecordCatalogRepository catalogRepo;
    @Mock
    private ValidationStatParquetRepository validationRepo;
    @Mock
    private NetworkRepository networkRepository;

    @InjectMocks
    private NetworkCleanWorker worker;

    @Test
    @DisplayName("Should create NetworkCleanWorker instance")
    void testConstructor() {
        assertNotNull(worker);
        assertEquals("NetworkCleanWorker", worker.getName());
    }

    @Test
    @DisplayName("Should initialize with deleteEntireNetwork as false")
    void testDefaultDeleteEntireNetwork() {
        assertFalse(worker.isDeleteEntireNetwork());
    }

    @Test
    @DisplayName("Should set and get deleteEntireNetwork")
    void testSetAndGetDeleteEntireNetwork() {
        worker.setDeleteEntireNetwork(true);
        assertTrue(worker.isDeleteEntireNetwork());

        worker.setDeleteEntireNetwork(false);
        assertFalse(worker.isDeleteEntireNetwork());
    }

    @Test
    @DisplayName("Should return 'Cleaner' toString when not deleting entire network")
    void testToStringCleaner() {
        worker.setDeleteEntireNetwork(false);
        assertEquals("Cleaner", worker.toString());
    }

    @Test
    @DisplayName("Should return 'Delete' toString when deleting entire network")
    void testToStringDelete() {
        worker.setDeleteEntireNetwork(true);
        assertEquals("Delete", worker.toString());
    }

    @Test
    @DisplayName("Should extend BaseWorker")
    void testInheritance() {
        assertTrue(worker instanceof org.lareferencia.core.worker.BaseWorker);
    }

    @Test
    @DisplayName("Should set running context")
    void testSetRunningContext() {
        NetworkRunningContext context = createMockContext();
        worker.setRunningContext(context);
        assertEquals(context, worker.getRunningContext());
    }

    @Test
    @DisplayName("Should set incremental mode")
    void testIncrementalMode() {
        assertFalse(worker.isIncremental());

        worker.setIncremental(true);
        assertTrue(worker.isIncremental());
    }

    @Test
    @DisplayName("Should set serial lane ID")
    void testSerialLaneId() {
        worker.setSerialLaneId(42L);
        assertEquals(42L, worker.getSerialLaneId());
    }

    @Test
    @DisplayName("Should set custom name")
    void testSetCustomName() {
        worker.setName("CustomCleaner");
        assertEquals("CustomCleaner", worker.getName());
    }

    @Test
    @DisplayName("Should handle null context")
    void testNullContext() {
        worker.setRunningContext(null);
        assertNull(worker.getRunningContext());
    }

    @Test
    @DisplayName("Should configure for partial clean")
    void testPartialClean() {
        worker.setDeleteEntireNetwork(false);

        assertFalse(worker.isDeleteEntireNetwork());
        assertEquals("Cleaner", worker.toString());
    }

    @Test
    @DisplayName("Should configure for full deletion")
    void testFullDeletion() {
        worker.setDeleteEntireNetwork(true);

        assertTrue(worker.isDeleteEntireNetwork());
        assertEquals("Delete", worker.toString());
    }

    @Test
    @DisplayName("End-to-end partial cleanup calls repo delete methods")
    void testPartialCleanupCallsRepos() throws Exception {
        NetworkRunningContext context = createMockContext();
        worker.setRunningContext(context);
        worker.setDeleteEntireNetwork(false);

        List<Long> snapshotIds = List.of(1L, 2L);
        when(snapshotStore.listSnapshotsIds(anyLong(), eq(false))).thenReturn(snapshotIds);
        when(snapshotStore.findLastGoodKnownSnapshot(any(Network.class))).thenReturn(999L);
        when(snapshotStore.findLastHarvestingSnapshot(any(Network.class))).thenReturn(888L);

        worker.run();

        verify(validationStatisticsService, times(2)).deleteValidationStatsObservationsBySnapshotID(anyLong());
        verify(catalogRepo, times(2)).deleteSnapshot(anyLong());
        verify(validationRepo, times(2)).deleteParquetForSnapshot(anyLong());
        verify(snapshotStore, times(2)).cleanSnapshotData(anyLong());
    }

    @Test
    @DisplayName("End-to-end full delete calls repo delete methods")
    void testFullDeleteCallsRepos() throws Exception {
        NetworkRunningContext context = createMockContext();
        worker.setRunningContext(context);
        worker.setDeleteEntireNetwork(true);

        List<Long> snapshotIds = List.of(1L, 2L);
        when(snapshotStore.listSnapshotsIds(anyLong(), eq(true))).thenReturn(snapshotIds);

        worker.run();

        verify(validationStatisticsService, times(2)).deleteValidationStatsObservationsBySnapshotID(anyLong());
        verify(catalogRepo, times(2)).deleteSnapshot(anyLong());
        verify(validationRepo, times(2)).deleteParquetForSnapshot(anyLong());
        verify(snapshotStore, times(2)).cleanSnapshotData(anyLong());
        verify(snapshotStore, times(2)).deleteSnapshot(anyLong());
        verify(networkRepository, times(1)).deleteByNetworkID(anyLong());
    }

    // Helper method
    private NetworkRunningContext createMockContext() {
        Network network = new Network();
        network.setAcronym("TEST");
        network.setName("Test Network");
        return new NetworkRunningContext(network);
    }
}
